# Implementation Plan: Local Kubernetes Deployment

**Branch**: `003-local-kubernetes` | **Date**: 2026-01-23 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/003-local-kubernetes/spec.md`

## Summary

Phase 4 enables container-based deployment of the Todo Evolution application to a local Kubernetes cluster (Minikube). This phase packages the existing FastAPI backend and Next.js frontend as Docker images, creates a Helm chart for deployment management, and establishes health checks, resource limits, and ingress routing. The implementation follows cloud-native best practices with multi-stage builds, non-root containers, and proper probe configurations.

**Key Technical Approach**:

- Multi-stage Docker builds for minimal image sizes
- Helm chart with templated Kubernetes resources
- Health checks using existing `/health` endpoint
- Local Minikube deployment with nginx ingress
- Resource limits and requests for all pods

## Technical Context

| Aspect                   | Specification                                                               |
| ------------------------ | --------------------------------------------------------------------------- |
| **Language/Version**     | Python 3.13 (backend), Node.js 20 (frontend build)                          |
| **Primary Dependencies** | FastAPI (backend), Next.js 16 (frontend), Helm 3.x, Minikube                |
| **Storage**              | SQLite (ephemeral in container)                                             |
| **Testing**              | `helm template --dry-run`, manual Minikube deployment                       |
| **Target Platform**      | Minikube (local Kubernetes) with nginx ingress                              |
| **Project Type**         | Web application (backend + frontend)                                        |
| **Performance Goals**    | Pods ready within 60s, health checks complete in 5s                         |
| **Constraints**          | 2+ CPU, 4+ GB RAM for Minikube; images load directly into Minikube registry |
| **Scale/Scope**          | 1-3 replicas per service for local testing                                  |

## Constitution Check

_GATE: Must pass before Phase 0 research. Re-check after Phase 1 design._

### Phase IV Compliance (Local Kubernetes)

| Principle                        | Status  | Notes                                               |
| -------------------------------- | ------- | --------------------------------------------------- |
| **I. Spec-Driven Development**   | ✅ PASS | Spec approved before plan                           |
| **II. Skills & Subagents First** | ✅ PASS | Helm skill exists at `.claude/skills/helm/SKILL.md` |
| **III. Context7 Knowledge**      | ✅ PASS | Helm patterns documented in skill                   |
| **IV. No Manual Coding**         | ✅ PASS | All artifacts generated via `/sp.implement`         |
| **V. Phase Governance**          | ✅ PASS | Phase IV scope: Docker, Helm, Minikube              |
| **VI. Technology Constraints**   | ✅ PASS | Uses mandated Docker, Helm, Minikube stack          |
| **VII. Agent Behavior**          | ✅ PASS | All work traceable to spec requirements             |
| **VIII. Quality Principles**     | ✅ PASS | Follows cloud-native patterns                       |
| **IX. Cloud-Native Readiness**   | ✅ PASS | Multi-stage builds, health checks, resource limits  |

### Specific Requirements Verified

- **Multi-stage Docker builds**: Required (FR-001) → Planned for both images
- **Non-root users**: Required (FR-003, NFR-004) → Both containers use `appuser:1000`
- **Health endpoints**: Required (FR-016 to FR-020) → Backend `/health` already exists
- **Resource limits**: Required (FR-007, NFR-003) → Configured in Helm values
- **Helm templates**: Required (FR-021 to FR-025) → All 8 templates planned
- **Single-command deployment**: Required (FR-026 to FR-028) → Script provided

**Gate Result**: ✅ **ALL PASSED** - Proceed to Phase 0 research

## Project Structure

### Documentation (this feature)

```text
specs/003-local-kubernetes/
├── plan.md              # This file
├── research.md          # Phase 0: Technology decisions
├── data-model.md        # Phase 1: Kubernetes resources model
├── quickstart.md        # Phase 1: Deployment guide
├── contracts/           # Phase 1: Helm contract
│   └── phase4-helm.md   # Copy of existing contract
├── checklists/
│   └── requirements.md  # Spec validation checklist
└── tasks.md             # Phase 2: Generated by /sp.tasks
```

### Source Code (repository root)

```text
backend/
├── app/                 # FastAPI application (existing)
│   ├── main.py          # Health check endpoint
│   ├── models.py        # Data models
│   ├── services/        # Business logic
│   └── routes/          # API routes
├── Dockerfile           # NEW: Backend container definition
├── .dockerignore        # NEW: Backend build exclusions
└── pyproject.toml       # Dependencies

frontend/
├── app/                 # Next.js App Router (existing)
│   ├── (auth)/          # Authentication pages
│   ├── (protected)/     # Protected pages
│   └── api/             # API routes
├── components/          # React components
├── Dockerfile           # NEW: Frontend container definition
├── .dockerignore        # NEW: Frontend build exclusions
├── next.config.ts       # Next.js config
└── package.json         # Dependencies

helm/
└── todo-app/            # NEW: Helm chart
    ├── Chart.yaml
    ├── values.yaml
    ├── values-cloud.yaml # Placeholder for Phase V
    └── templates/
        ├── _helpers.tpl
        ├── backend-deployment.yaml
        ├── backend-service.yaml
        ├── frontend-deployment.yaml
        ├── frontend-service.yaml
        ├── configmap.yaml
        ├── secret.yaml
        └── ingress.yaml

scripts/
└── deploy-minikube.sh   # NEW: Automated deployment script
```

**Structure Decision**: Option 2 (Web application) selected. Backend and frontend are separate containerized applications deployed via Helm. Helm chart is new infrastructure code.

## Complexity Tracking

> **No violations requiring justification**

All architecture decisions follow standard cloud-native patterns and comply with constitution principles.

---

## Phase 0: Research & Technology Decisions

### Research Tasks

| #   | Topic                     | Questions                                                              | Decision Source            |
| --- | ------------------------- | ---------------------------------------------------------------------- | -------------------------- |
| R1  | Next.js standalone output | Does Next.js 16 support standalone output for Docker?                  | Context7: Next.js          |
| R2  | Python Docker multi-stage | What's the recommended multi-stage pattern for FastAPI?                | Context7: FastAPI + Docker |
| R3  | Minikube ingress          | How to enable nginx ingress in Minikube?                               | Existing Helm skill        |
| R4  | Image loading             | How to load images into Minikube without external registry?            | Minikube documentation     |
| R5  | Resource limits           | What are reasonable CPU/memory limits for FastAPI/Next.js in Minikube? | Kubernetes best practices  |

### Decisions Documented

See `research.md` (generated below) for full rationale on each decision.

---

## Phase 1: Design & Contracts

### Data Model (Kubernetes Resources)

The "data model" for this phase is the Kubernetes resource structure:

| Resource Type  | Purpose              | Key Attributes                           |
| -------------- | -------------------- | ---------------------------------------- |
| **Deployment** | Pod management       | replicas, selector, template, containers |
| **Service**    | Network endpoint     | type (ClusterIP), ports, selector        |
| **Ingress**    | External routing     | host, paths, backend services            |
| **ConfigMap**  | Non-sensitive config | environment variables                    |
| **Secret**     | Sensitive data       | API keys, database URLs                  |

See `data-model.md` for complete entity definitions.

### API Contracts

No new API contracts - existing REST APIs are containerized. The Helm chart contract is documented in `contracts/phase4-helm.md`.

### Health Endpoints

| Service  | Endpoint            | Expected Response                                     |
| -------- | ------------------- | ----------------------------------------------------- |
| Backend  | GET /health         | 200: `{"status": "healthy"}`                          |
| Backend  | GET /health/with-db | 200: `{"status": "healthy", "database": "connected"}` |
| Frontend | GET /               | 200: HTML page                                        |

---

## Architecture Decisions

### AD-001: Use SQLite for Minikube Deployment

**Decision**: Use SQLite with in-container storage for Minikube deployment.

**Rationale**:

- Simplifies local development (no external database setup)
- Sufficient for single-replica testing
- Data is ephemeral (acceptable for local testing)
- Reduces complexity of Minikube setup

**Trade-offs**:

- Pro: No database pod to manage
- Pro: Faster startup
- Con: Data lost on pod restart (acceptable for testing)
- Con: Not production-ready (Phase V will use PostgreSQL)

**Alternatives Considered**:

- PostgreSQL in Kubernetes: More realistic but adds complexity
- Neon Cloud external: Requires network, harder to test locally

### AD-002: Load Images Directly into Minikube

**Decision**: Build images locally and load into Minikube using `minikube image load`.

**Rationale**:

- No external registry needed for local development
- Faster iteration (no push/pull)
- Works offline

**Trade-offs**:

- Pro: Simple local workflow
- Pro: No registry setup
- Con: Images must be reloaded after rebuild
- Con: Not scalable to team deployment (use registry for that)

**Alternatives Considered**:

- Docker Hub: Requires public/private registry setup
- Local registry: Adds another service to run

### AD-003: Single Helm Chart for Backend + Frontend

**Decision**: One Helm chart deploys both backend and frontend.

**Rationale**:

- Single command deploys entire application
- Shared configuration (namespace, ingress)
- Simpler for local development
- Can split later if needed for Phase V

**Trade-offs**:

- Pro: Simpler deployment
- Pro: Coordinated versioning
- Con: Tighter coupling (acceptable for monorepo)

**Alternatives Considered**:

- Separate charts: More flexible but more complex

---

## Implementation Phases

### Phase 0: Research (Generates research.md)

1. Research Next.js 16 Docker deployment patterns
2. Research FastAPI multi-stage Docker builds
3. Document Minikube ingress setup
4. Document image loading strategy
5. Validate resource limit recommendations

### Phase 1: Core Artifacts (Generates data-model.md, contracts/, quickstart.md)

1. Create `data-model.md` with Kubernetes resource definitions
2. Copy/adapt `contracts/phase4-helm.md` from existing spec
3. Create `quickstart.md` with Minikube setup instructions
4. Update agent context with Helm/Docker knowledge

### Phase 2: Docker Images (Implementation via /sp.implement)

1. Create `backend/Dockerfile` (multi-stage build)
2. Create `backend/.dockerignore`
3. Create `frontend/Dockerfile` (multi-stage build with standalone output)
4. Create `frontend/.dockerignore`
5. Verify images build locally

### Phase 3: Helm Chart (Implementation via /sp.implement)

1. Create `helm/todo-app/Chart.yaml`
2. Create `helm/todo-app/values.yaml`
3. Create `helm/todo-app/templates/_helpers.tpl`
4. Create backend Deployment and Service templates
5. Create frontend Deployment and Service templates
6. Create ConfigMap and Secret templates
7. Create Ingress template
8. Validate with `helm template --dry-run`

### Phase 4: Deployment Script (Implementation via /sp.implement)

1. Create `scripts/deploy-minikube.sh`
2. Add Minikube startup checks
3. Add ingress enablement
4. Add image build and load commands
5. Add Helm install command
6. Add post-deployment verification

### Phase 5: Testing & Validation

1. Deploy to clean Minikube cluster
2. Verify all pods become ready
3. Test ingress routing
4. Test health checks
5. Test scaling (increase replicas)
6. Test upgrade (Helm upgrade)
7. Test rollback
8. Document any issues

---

## Risk Mitigation

| Risk                             | Impact | Mitigation                                                 |
| -------------------------------- | ------ | ---------------------------------------------------------- |
| Minikube resource constraints    | High   | Document minimum requirements (2 CPU, 4 GB RAM)            |
| Next.js standalone config issues | Medium | Verify `output: 'standalone'` in next.config.ts            |
| Image loading failures           | Medium | Provide script with error checking                         |
| Ingress not available            | Medium | Document ingress enablement; provide port-forward fallback |
| Health check timing              | Medium | Configure generous initial delays (10-15s)                 |
| SQLite path issues               | Low    | Use absolute path `/app/data/todo.db`                      |
| Port conflicts                   | Low    | Use standard ports (8000, 3000) inside cluster             |

---

## Success Metrics

| Metric               | Target                            | How to Measure                             |
| -------------------- | --------------------------------- | ------------------------------------------ |
| Deployment time      | < 3 minutes                       | Time from `helm install` to all pods ready |
| Pod startup time     | < 60 seconds                      | `kubectl get pods` - Age column            |
| Health check success | 100%                              | All probes return 200                      |
| Image size           | Backend < 200MB, Frontend < 300MB | `docker images`                            |
| Helm validation      | Pass                              | `helm template --dry-run`                  |
| Rolling update       | Zero downtime                     | Application responds during upgrade        |
| Resource usage       | Within limits                     | `kubectl top pods`                         |

---

## Next Steps

1. ✅ This plan (`/sp.plan`) is complete
2. → Run `/sp.tasks` to generate task breakdown
3. → Run `/sp.implement` to execute the tasks

**Generated Artifacts** (to be created by this command):

- `research.md` - Technology research and decisions
- `data-model.md` - Kubernetes resource entities
- `quickstart.md` - Developer quickstart guide
- `contracts/phase4-helm.md` - Copy of existing contract
